/*
 * rf-rfm95.c
 *
 *  Created on: Dec 25, 2024
 *      Author: abina
 */
#include "rf-rfm95.h"

#include "ansi-codes.h"

#define LOG_ERROR(M, ...) printf( "[Abi's RFlib]" SETFG_RED "[ERROR] (%s:%d) " M GR_RESET "\r\n", __FILE__, __LINE__, ##__VA_ARGS__)

#define LOG_WARN(M, ...) printf( "[Abi's RFlib]" SETFG_YELLOW "[WARN] " M GR_RESET "\r\n", ##__VA_ARGS__)

#define LOG_INFO(M, ...) printf("[Abi's RFlib][INFO] " M "\r\n", ##__VA_ARGS__)

int rf_initialize_radio(rf_handle_t *rf_handle) {
	if (rf_handle == NULL)
		return 0;

	if (rf_handle->rf_spi_timeout == NULL)
		rf_handle->rf_spi_timeout = 100;

	if (rf_handle->rf_module_identifier == NULL)
		rf_handle->rf_module_identifier = -1;

	printf("\r\n");

	LOG_INFO(SETFG_GREEN "Initializing module" GR_RESET,
			rf_handle->rf_module_identifier);

	rf_reset(rf_handle);

	// check version
	uint8_t version;
	if (!rf_spi_read_register(rf_handle, RegVersion, &version)) {
		LOG_ERROR("Module did not return a version; SPI Error");
		return 0;
	}

	if (RFM9x_VER != version) {
		LOG_ERROR("Module did not return the correct version");
		return 0;
	}

	LOG_INFO("Module Available; \x1b[34;1;4mVersion: 0x%x\x1b[0m", version);

// Module must be placed in sleep mode before switching to lora.

	rf_register_op_mode_config_t opmode = { 0 };

	opmode.long_range_mode = 1;
	opmode.mode = RF_OP_MODE_SLEEP;

	if (!rf_spi_write_register(rf_handle, RegOpMode, opmode.op_mode))
		return 0;

	// Default interrupt configuration, must be done to prevent DIO5 clock interrupts at 1Mhz
	// Table 17
	rf_register_dio_mapping_1_config_t diomapping1 = { 0 };

	diomapping1.dio_0_mapping = 0b00;
	diomapping1.dio_1_mapping = 0b00;
	diomapping1.dio_2_mapping = 0b00;
	diomapping1.dio_3_mapping = 0b00;

	if (!rf_spi_write_register(rf_handle, RegDioMapping1,
			diomapping1.dio_mapping_1))
		return 0;

	rf_register_dio_mapping_2_config_t diomapping2 = { 0 };

	diomapping2.dio_4_mapping = 0b00;
	diomapping2.dio_5_mapping = 0b00;

	if (!rf_spi_write_register(rf_handle, RegDioMapping2,
			diomapping2.dio_mapping_2))
		return 0;

	if (rf_handle->rf_post_init_clbk != NULL) {
		rf_handle->rf_post_init_clbk();
	}

	// Set module power to 17dbm.
	if (!rf_set_tx_power(rf_handle, 15))
		return 0;

	// Set LNA to the highest gain with 150% boost.

	rf_register_lna_config_t reglna = { .LnaGain = 0b001, .LnaBoostLf = 0b00,
			.reserved = 0, .LnaBoostHf = 0b11 };
	if (!rf_spi_write_register(rf_handle, RegLna, reglna.lna_config))
		return 0;

	// Preamble set to 8 + 4.25 = 12.25 symbols.
	if (!rf_spi_write_register(rf_handle, RegPreambleMsb, 0x00))
		return 0;
	if (!rf_spi_write_register(rf_handle, RegPreambleLsb, 0x08))
		return 0;

	// Set TTN sync word 0x34.
	if (!rf_spi_write_register(rf_handle, RegSyncWord, 0x34))
		return 0;

	// Set up TX and RX FIFO base addresses.
	if (!rf_spi_write_register(rf_handle, RegFifoTxBaseAddr, 0x80))
		return 0;
	if (!rf_spi_write_register(rf_handle, RegFifoRxBaseAddr, 0x00))
		return 0;

	// Maximum payload length of the RFM95 is 64.
	if (!rf_spi_write_register(rf_handle, RegMaxPayloadLength, 64))
		return 0;

	uint8_t payload = 0;

	if (!rf_spi_read_register(rf_handle, RegMaxPayloadLength, &payload))
		return 0;

	// Let module sleep after initialization.
	if (!rf_spi_write_register(rf_handle, RegOpMode,
	RFM95_REGISTER_OP_MODE_LORA_SLEEP))
		return 0;

	// make sure this is defined
	rf_set_frequency(rf_handle, rf_handle->rf_carrier_frequency);

	rf_register_modem_config_3_t rf_modem_config_3 = { .agc_auto_on = 0b1,
			.low_data_rate_optimize = 0b0 };

	if (!rf_spi_write_register(rf_handle, RegModemConfig3,
			rf_modem_config_3.modem_config_3))
		return 0;

	rf_register_op_mode_config_t rf_op_mode_config = { .access_shared_reg = 0,
			.long_range_mode = 1, .low_frequency_mode_on = 0, .mode = 0b001 };

	// idle in lora mode
	if (!rf_spi_write_register(rf_handle, RegOpMode, rf_op_mode_config.op_mode))
		return 0;

	return 1;

}

int rf_send(rf_handle_t *rf_handle, uint8_t *buffer, uint8_t length_bytes) {

	rf_register_op_mode_config_t current_op_mode = { 0 };
	if (!rf_spi_read_register(rf_handle, RegOpMode, &current_op_mode.op_mode))
		return 0;

	// check if in transmit mode.
	if (RF_OP_MODE_TX == current_op_mode.mode) {

		LOG_WARN("Module in TX unable to send.");
		return 0;
	}
	// here, since the module is not transmitting lets clear the inturrpt flags for tx done.
	rf_register_irq_flags_t irq_flags = { 0 };
	if (!rf_spi_read_register(rf_handle, RegIrqFlags, &irq_flags.irq_flags))
		return 0;
	// if the flag is still set
	if (irq_flags.tx_done) {
		// then clear it.
		irq_flags.irq_flags = 0b0; // first set all else to 0
		irq_flags.tx_done = 1;
		if (!rf_spi_write_register(rf_handle, RegIrqFlags, irq_flags.irq_flags))
			return 0;
	}

	// put in idle lora
	rf_register_op_mode_config_t idle_op_mode = { 0 };
	idle_op_mode.long_range_mode = 1;
	idle_op_mode.mode = RF_OP_MODE_STDBY;
	if (!rf_spi_write_register(rf_handle, RegOpMode, idle_op_mode.op_mode))
		return 0;

	// TODO: add a global that configures the implicit or explicit header mode.

	rf_register_modem_config_1_t modem_config_1 = { 0 };
	if (!rf_spi_read_register(rf_handle, RegModemConfig1,
			&modem_config_1.modem_config_1))
		return 0;

	// Default to implicit header.
	modem_config_1.implicit_header_mode_on = 1;
	if (!rf_spi_write_register(rf_handle, RegModemConfig1,
			modem_config_1.modem_config_1))
		return 0;

	// Reset fifo address and payload length

	if (!rf_spi_write_register(rf_handle, RegFifoAddrPtr, 0))
		return 0;

	if (!rf_spi_write_register(rf_handle, RegPayloadLength, 0)) // set to 0 for now.
		return 0;

	// add data

	// check size TODO: optimize this since it is constant.
	uint8_t max_payload_length = 0;
	if (!rf_spi_read_register(rf_handle, RegMaxPayloadLength,
			&max_payload_length))
		return 0;

	if (max_payload_length < length_bytes) {
		printf(
				"\x1b[31;4;3;1m[Abi's RFlib] [%d] [ERROR] Max payload length exceeded with %d; max is %d.\x1b[0m\r\n",
				rf_handle->rf_module_identifier, max_payload_length,
				length_bytes);
	}

	uint8_t current_payload_length = 0;
	if (!rf_spi_read_register(rf_handle, RegPayloadLength,
			&current_payload_length))
		return 0;

	// never should happen cuz we reset the payload length above
	if (current_payload_length + length_bytes > max_payload_length) {
		printf(
				"\x1b[31;4;3;1m[Abi's RFlib] [%d] [ERROR] Old buffer not clear and adding current bytes exceeds max payload %d, prev %d, new %d.\x1b[0m\r\n",
				rf_handle->rf_module_identifier, max_payload_length,
				current_payload_length, length_bytes);
	}

	// fill fifo
	// write data to module
	for (int i = 0; i < length_bytes; i++) {
		if (!rf_spi_write_register(rf_handle, RegFifo, buffer[i])) {
			printf(
					"\x1b[31;4;3;1m[Abi's RFlib] [%d] [ERROR] Buffer fifo write error\x1b[0m\r\n",
					rf_handle->rf_module_identifier);
			return 0;
		}
	}

	// update the payload length
	if (!rf_spi_write_register(rf_handle, RegPayloadLength, length_bytes))
		return 0;

	// end packet and send
	rf_register_dio_mapping_1_config_t dio_mapping_1 = { 0 };

	//TODO: use dio0 inturrupt

	// put in tx mode
	rf_register_op_mode_config_t tx_mode_config = { 0 };
	tx_mode_config.long_range_mode = 1;
	tx_mode_config.mode = RF_OP_MODE_TX;

	if (!rf_spi_write_register(rf_handle, RegOpMode, tx_mode_config.op_mode))
		return 0;

	rf_register_op_mode_config_t temp_mode_config = { 0 };
	if (!rf_spi_read_register(rf_handle, RegOpMode, &tx_mode_config.op_mode))
		return 0;

	// Blocking

	rf_register_irq_flags_t tx_done_flags = { 0 };
	if (!rf_spi_read_register(rf_handle, RegIrqFlags, &tx_done_flags.irq_flags))
		return 0;
	while (!tx_done_flags.tx_done) {
		HAL_Delay(1);
		if (!rf_spi_read_register(rf_handle, RegIrqFlags,
				&tx_done_flags.irq_flags))
			return 0;
	}

	// done sending
	// clear flags
	tx_done_flags.irq_flags = 0;		// 0 out the rest
	tx_done_flags.tx_done = 1;		// set the tx done bit to clear.

	// clear the tx done flag for next packet.
	if (!rf_spi_write_register(rf_handle, RegIrqFlags, tx_done_flags.irq_flags))
		return 0;

	return 1;
}

int rf_set_frequency(rf_handle_t *rf_handle, uint32_t rf_carrier_frequency) {

// FQ = (FRF * 32 Mhz) / (2 ^ 19)
	uint64_t frf = ((uint64_t) rf_carrier_frequency << 19) / 32000000;

	if (!rf_spi_write_register(rf_handle, RegFrfMsb, (uint8_t) (frf >> 16)))
		return 0;
	if (!rf_spi_write_register(rf_handle, RegFrfMid, (uint8_t) (frf >> 8)))
		return 0;
	if (!rf_spi_write_register(rf_handle, RegFrfLsb, (uint8_t) (frf >> 0)))
		return 0;

	return 1;

}

int rf_set_tx_power(rf_handle_t *rf_handle, uint8_t rf_power_dbm) {

	if (!((rf_power_dbm >= 2 && rf_power_dbm <= 17) || (rf_power_dbm == 20))) {

		LOG_ERROR("Unable to set power to %d out of range.", rf_power_dbm);
		return 0;
	}

	rf_register_pa_config_t reg_pa_config;
	uint8_t reg_pa_dac_config = 0;

	if (rf_power_dbm >= 2 || rf_power_dbm <= 17) {
		reg_pa_config.max_power = 7;
		reg_pa_config.pa_select = 1;
		reg_pa_config.output_power = (rf_power_dbm - 2);
		reg_pa_dac_config = RFM95_REGISTER_PA_DAC_LOW_POWER;
	} else if (rf_power_dbm == 20) {
		reg_pa_config.max_power = 7;
		reg_pa_config.pa_select = 1;
		reg_pa_config.output_power = 15;
		reg_pa_dac_config = RFM95_REGISTER_PA_DAC_HIGH_POWER;
	}

	if (!rf_spi_write_register(rf_handle, RegPaConfig,
			reg_pa_config.pa_config)) {

		LOG_ERROR("Unable to set power to %d SPI write error.", rf_power_dbm);
		return 0;
	}
	if (!rf_spi_write_register(rf_handle, RegPaDac, reg_pa_dac_config)) {

		LOG_ERROR("Unable to set power to %d SPI write error.", rf_power_dbm);
		return 0;
	}

	LOG_INFO("Set power to %d.", rf_power_dbm);

	return 1;

}

int rf_inturrupt_clbk(rf_handle_t *rf_handle, rf_interrupt_t rf_inturrupt) {

	return 1;

}

int rf_spi_read_register(rf_handle_t *rf_handle, uint8_t rf_register_address,
		uint8_t *rf_register_result) {

// 0 the MSB since that is the wnr bit. we are reading so it must be 0.
	uint8_t prep_register = rf_register_address & 0x7f;

	HAL_GPIO_WritePin(rf_handle->rf_nss_port, rf_handle->rf_nss_pin,
			GPIO_PIN_RESET);

	if (HAL_SPI_Transmit(rf_handle->rf_spi_handle, &prep_register, 1,
			rf_handle->rf_spi_timeout) != HAL_OK) {
		LOG_ERROR("Failed to read register 0x%x", rf_register_address);
		return 0;
	}

	if (HAL_SPI_Receive(rf_handle->rf_spi_handle, rf_register_result, 1,
			rf_handle->rf_spi_timeout) != HAL_OK) {
		LOG_ERROR("Failed to read register 0x%x", rf_register_address);
		return 0;
	}

	HAL_GPIO_WritePin(rf_handle->rf_nss_port, rf_handle->rf_nss_pin,
			GPIO_PIN_SET);
	return 1;
}

int rf_spi_write_register(rf_handle_t *rf_handle, uint8_t rf_register_address,
		uint8_t rf_register_value) {
// 1 the MSB since that is the wnr bit. we are writing so it must be 1.
	uint8_t prep_register_buffer[2] = { ((uint8_t) rf_register_address | 0x80u),
			rf_register_value };

	HAL_GPIO_WritePin(rf_handle->rf_nss_port, rf_handle->rf_nss_pin,
			GPIO_PIN_RESET);

	if (HAL_SPI_Transmit(rf_handle->rf_spi_handle, prep_register_buffer, 2,
			rf_handle->rf_spi_timeout) != HAL_OK) {
		LOG_ERROR("Failed to set register 0x%x : 0x%x", rf_register_address,
				rf_register_value);
		return 0;
	}

	HAL_GPIO_WritePin(rf_handle->rf_nss_port, rf_handle->rf_nss_pin,
			GPIO_PIN_SET);

	return 1;

}

int rf_reset(rf_handle_t *rf_handle) {

//	printf(
//			"\x1b[33;1;3;4m[Abi's RFlib] [%d] [WARN] : Reseting module\x1b[0m\r\n",
//			rf_handle->rf_module_identifier);

	LOG_WARN("Reseting module");

	HAL_GPIO_WritePin(rf_handle->rf_nreset_port, rf_handle->rf_nreset_pin,
			GPIO_PIN_RESET);
	rf_handle->rf_delay_func(100);
	HAL_GPIO_WritePin(rf_handle->rf_nreset_port, rf_handle->rf_nreset_pin,
			GPIO_PIN_SET);
	rf_handle->rf_delay_func(100);

	return 1;

}

int rf_set_sync_word(rf_handle_t *rf_handle) {
	return 1;
}

int rf_listen(rf_handle_t *rf_handle) {
	return 1;
}

int rf_listen_implicit(rf_handle_t *rf_handle, uint8_t size) {
	if (size <= 0) {
		LOG_ERROR("Listen size must be 1 byte or larger");
		return 0;
	}

	rf_register_dio_mapping_1_config_t diomapping1 = { 0 };

	// get the current modem config then change to implicit.

	if (!rf_spi_read_register(rf_handle, RegModemConfig1,
			&diomapping1.dio_mapping_1)) {
		LOG_ERROR("SPI Error");
		return 0;
	}

	diomapping1.dio_0_mapping = 0b00;

	if (!rf_spi_write_register(rf_handle, RegDioMapping1,
			diomapping1.dio_mapping_1)) { // DIO0 => RXDONE
		LOG_ERROR("SPI Error");
		return 0;
	}

	rf_register_modem_config_1_t implicit_header_mode = { 0 };
	implicit_header_mode.implicit_header_mode_on = 1;

	if (!rf_spi_write_register(rf_handle, RegModemConfig1,
			implicit_header_mode.modem_config_1)) {
		LOG_ERROR("SPI Error");
		return 0;
	}

	if (!rf_spi_write_register(rf_handle, RegPayloadLength, size)) {
		LOG_ERROR("SPI Error");
		return 0;
	}

	rf_register_op_mode_config_t recieve_lora_mode = { 0 };
	recieve_lora_mode.long_range_mode = 1;
	recieve_lora_mode.mode = RF_OP_MODE_RXCONTINUOUS;

	if (!rf_spi_write_register(rf_handle, RegOpMode,
			recieve_lora_mode.op_mode)) {
		LOG_ERROR("SPI Error");
		return 0;
	}

	return 1;
}

int rf_available(rf_handle_t *rf_handle) {

	uint8_t num_bytes_recieved = 0;

	if (!rf_spi_read_register(rf_handle, RegRxNbBytes, &num_bytes_recieved)) {
		LOG_ERROR("SPI ERROR");
		return 0;
	}
	return num_bytes_recieved;
}
